# jicanicle アーキテクチャ再設計提案

## 更新履歴

| 日付 | 更新者 | 内容 |
|------|--------|------|
| 2025-03-10 | 開発チーム | 初版作成：核機能に基づくアーキテクチャ再設計提案 |

## 1. はじめに

本ドキュメントは、jicanicleプロジェクトが直面している技術的課題（TUIのテスト困難性、Reactの複雑なコンテキスト依存、過度に複雑化したアーキテクチャ）を解決し、核となる機能要件を効果的に実現するための、アーキテクチャ再設計の提案を行うものです。「何を実現すべきか」という本質に立ち返り、より保守性が高く拡張しやすいアーキテクチャを目指します。

## 2. 現状の課題分析

### 2.1 技術的課題の詳細

1. **TUIのテスト困難性**
   - 現状: Inkベースの実装がテスト自動化を難しくしている
   - 問題点: UIの変更が他のコンポーネントに及ぼす影響を検証しづらい
   - 影響: 品質保証の労力増大とリファクタリングの障壁

2. **Reactの複雑なコンテキスト依存**
   - 現状: 複数のReactコンテキストが複雑に絡み合っている
   - 問題点: コンポーネント間の依存関係が暗黙的で追跡困難
   - 影響: 変更の影響範囲予測が難しく、バグの温床に

3. **過度に複雑化したアーキテクチャ**
   - 現状: 当初の設計から機能拡張を重ねた結果、構造が複雑化
   - 問題点: レイヤー間の責務の曖昧化と依存関係の複雑化
   - 影響: 新機能追加や変更のコストが高く、拡張性の低下

### 2.2 アーキテクチャ上の課題

1. **境界の曖昧さ**
   - バウンデッドコンテキスト間の境界が不明確
   - 責務の重複や漏れが発生

2. **依存関係の複雑さ**
   - 循環依存の発生
   - インターフェースの肥大化

3. **テスト容易性の欠如**
   - 外部依存の直接結合
   - モックやスタブの作成困難

## 3. 再設計の原則

技術的課題を解決し、核となる機能要件を効果的に実現するための原則は以下の通りです：

### 3.1 設計原則

1. **シンプリシティ優先**
   - 最小限のコンポーネントとインターフェース
   - 不必要な抽象化を避ける
   - 本質的な機能に集中

2. **関心の明確な分離**
   - 各バウンデッドコンテキストの責務を厳格に定義
   - レイヤー間の依存方向を一貫させる
   - ドメインロジックをインフラや表示から独立させる

3. **テスト駆動設計**
   - テスト容易性を設計の出発点とする
   - ドメインロジックの高いテストカバレッジを確保
   - UIとインフラをテスト可能な形で分離

4. **ユーザー中心設計**
   - UX要件から設計を導出
   - 実装の複雑さよりもユーザー価値を優先
   - シンプルな操作性を担保

### 3.2 アーキテクチャパターン

新アーキテクチャでは、以下のパターンを採用します：

1. **ヘキサゴナルアーキテクチャ（ポートとアダプター）**
   - ドメインロジックを中心に据えたポートとアダプターの設計
   - 外部依存の抽象化と入れ替え容易性の確保
   - UIやストレージ実装からの独立性確保

2. **イベント駆動アーキテクチャ**
   - コンテキスト間の疎結合を実現するイベントベースの連携
   - 非同期操作のサポート
   - スケーラビリティの確保

3. **関数型アプローチ**
   - 不変性と純粋関数による予測可能性
   - 副作用の明示的な取り扱い
   - 型安全性の確保

## 4. 新アーキテクチャの概要

### 4.1 全体構造

新しいアーキテクチャは、以下の4つの主要レイヤーで構成します：

```
【 UI レイヤー 】UI実装に依存しない適応レイヤー
    ↑
【 アプリケーション レイヤー 】ユースケースオーケストレーション
    ↑
【 ドメイン レイヤー 】核となるビジネスロジック
    ↑
【 インフラストラクチャ レイヤー 】技術詳細の実装
```

各レイヤーは明確な責務を持ち、依存関係は内側に向かっています。特に、ドメインレイヤーは他のどのレイヤーにも依存せず、純粋なビジネスロジックに集中します。

### 4.2 バウンデッドコンテキストの再定義

各バウンデッドコンテキストを以下のように再定義し、責務を明確にします：

#### タスク管理コンテキスト

- **中核責務**: タスクのライフサイクル管理
- **主要概念**: タスク、カテゴリ、状態、タグ
- **境界**: タスクのCRUD操作とメタデータ管理

#### タイムブロックコンテキスト

- **中核責務**: タスクのスケジューリングと時間配分
- **主要概念**: タイムブロック、スケジュール、時間枠
- **境界**: スケジュール生成と管理、タイムブロックCRUD

#### タイムトラッキングコンテキスト

- **中核責務**: 作業時間の記録と分析
- **主要概念**: トラッキングセッション、実績、休憩
- **境界**: 時間記録と統計処理

#### 予測コンテキスト

- **中核責務**: タスク所要時間とカテゴリの予測
- **主要概念**: 予測結果、フィードバック、学習データ
- **境界**: 予測生成とモデル更新

### 4.3 コンテキスト間の連携

コンテキスト間の連携は、以下の二つのアプローチを組み合わせます：

1. **明示的なコンテキストマップ**
   - 各コンテキスト間の関係性を明示的に定義
   - 共有カーネルとアンチコラプションレイヤーの活用
   - 変換関数による概念の翻訳

2. **イベント駆動の統合**
   - ドメインイベントによる疎結合な連携
   - メッセージキューパターンによる非同期処理
   - イベントソーシング手法の部分的適用

## 5. 各レイヤーの詳細設計

### 5.1 ドメインレイヤー

ドメインレイヤーは、ビジネスロジックの中核として、以下の要素で構成されます：

```
src/domain/
├── [コンテキスト名]/
│   ├── models/        # エンティティと値オブジェクト
│   ├── events/        # ドメインイベント
│   ├── services/      # ドメインサービス
│   ├── factories/     # ファクトリ関数
│   ├── commands/      # コマンド関数
│   ├── queries/       # クエリ関数
│   └── ports/         # 外部サービスのインターフェース（リポジトリなど）
```

- **依存方向**: 内側方向のみ（他のレイヤーに依存しない）
- **実装アプローチ**: 関数型スタイルで純粋関数を優先
- **テスト戦略**: 詳細なユニットテストで高いカバレッジを確保

### 5.2 アプリケーションレイヤー

アプリケーションレイヤーは、ユースケースを実装し、ドメインオブジェクトを調整します：

```
src/application/
├── [ユースケース名]/
│   ├── handlers/      # ユースケースハンドラ
│   ├── commands/      # アプリケーションコマンド
│   ├── queries/       # アプリケーションクエリ
│   └── dtos/          # データ転送オブジェクト
├── services/          # アプリケーションサービス
└── events/            # アプリケーションイベント
```

- **依存方向**: ドメインレイヤーのみに依存
- **実装アプローチ**: ドメインオブジェクトの調整と外部リソースの調整
- **テスト戦略**: モック/スタブを使用したユニットテストと統合テスト

### 5.3 インフラストラクチャレイヤー

インフラストラクチャレイヤーは、技術的な詳細と外部リソースとの統合を担当します：

```
src/infrastructure/
├── adapters/          # 外部サービスのアダプター
│   ├── storage/       # ストレージアダプター（ファイル、DB等）
│   ├── ai/            # AI予測サービスアダプター
│   └── events/        # イベントバスアダプター
├── repositories/      # リポジトリ実装
├── services/          # インフラサービス
└── config/            # 設定関連
```

- **依存方向**: ドメインとアプリケーションレイヤーのインターフェースに依存
- **実装アプローチ**: ドメインポートを実装するアダプター
- **テスト戦略**: 統合テストとモックを使用したユニットテスト

### 5.4 UIレイヤー

UIレイヤーは、特定のUIフレームワークに依存しない形で設計します：

```
src/ui/
├── adapters/          # UI適応レイヤー
│   ├── presenters/    # プレゼンター
│   ├── controllers/   # コントローラー
│   └── view-models/   # ビューモデル
├── ports/             # UIポート（インターフェース）
└── [実装]/            # 具体的なUI実装
    ├── ink/           # Ink（TUI）実装
    ├── react/         # React Web実装（将来拡張用）
    └── cli/           # コマンドライン実装
```

- **依存方向**: アプリケーションレイヤーに依存
- **実装アプローチ**: MVP/MVVMパターンでロジックとUIを分離
- **テスト戦略**: プレゼンターとビューモデルのユニットテスト

## 6. テスト容易性の向上

テスト容易性を向上させるために、以下の設計改善を行います：

### 6.1 ドメインテスト

- 純粋関数として実装されたドメインロジックの詳細テスト
- 参照透過性を活用したプロパティベーステスト
- ドメインサービスのモックを使用しない単体テスト

### 6.2 インターフェースベースのテスト

- リポジトリやサービスのインメモリ実装によるテスト
- 明示的なポートとアダプターによるモック簡素化
- 依存性注入を活用したテスト環境構築

### 6.3 UIテスト

- プレゼンターとビューの分離によるロジックテスト
- UI実装に依存しないビジネスロジックテスト
- ヘッドレステストによるUI操作検証

### 6.4 統合テスト

- 各バウンデッドコンテキスト間の連携テスト
- イベント伝播の検証
- エンドツーエンドの主要フロー検証

## 7. 移行戦略

新しいアーキテクチャへの移行は、以下の段階的アプローチで実施します：

### 7.1 段階的リファクタリング

1. **ドメインモデルの純化と再定義**
   - 現行コードからドメインロジックを抽出
   - 新しいドメインモデルを定義
   - ドメインテストの作成

2. **アプリケーションレイヤーの再構築**
   - ユースケースの明確化
   - アプリケーションサービスの実装
   - 既存コードとの橋渡し実装

3. **インフラストラクチャの段階的置き換え**
   - 新しいリポジトリ実装の作成
   - 外部サービスアダプターの開発
   - データマイグレーション

4. **UIの段階的移行**
   - プレゼンターの実装
   - 新しいUI適応レイヤーの構築
   - 古いUIコンポーネントの置き換え

### 7.2 並行開発アプローチ

- **ストラングラーフィグパターン**
  - 新機能は新アーキテクチャで開発
  - 既存機能は段階的に新アーキテクチャに移行
  - 移行中はアダプターで新旧アーキテクチャを連携

- **フィーチャーフラグ**
  - 新しい実装を段階的に有効化
  - ユーザーに影響を与えないテスト環境での検証
  - 段階的なロールアウト

### 7.3 技術スタックの選定

新アーキテクチャへの移行に際しては、以下の技術選択を推奨します：

- **言語**: TypeScript（型安全性と開発効率のバランス）
- **テスト**: Vitest（高速で設定が簡単）
- **状態管理**: Zustand（シンプルで柔軟性が高い）
- **バリデーション**: Zod（型安全なスキーマ定義）
- **エラーハンドリング**: neverthrow（関数型エラーハンドリング）
- **UIオプション**:
  - Ink（TUIの継続利用）
  - React（Webへの拡張可能性）
  - CLI（ヘッドレス操作）

## 8. 利点とリスク

### 8.1 期待される利点

1. **保守性の向上**
   - 関心の明確な分離による変更の局所化
   - 純粋な関数による予測可能性
   - テストカバレッジの向上

2. **拡張性の向上**
   - 新しいUIの追加が容易
   - 異なるAI予測エンジンへの切り替え容易性
   - ストレージメカニズムの拡張

3. **品質向上**
   - テスト容易性による品質保証強化
   - 型安全性による実行時エラーの削減
   - 明確な責務分担によるバグ混入リスク低減

### 8.2 リスクと対策

1. **移行コスト**
   - リスク: 大規模なリファクタリングにリソースが必要
   - 対策: 段階的なアプローチで機能を維持しながら移行

2. **チームの学習曲線**
   - リスク: 新しいアーキテクチャパターンの習得が必要
   - 対策: ドキュメントの充実とペアプログラミングの実施

3. **過度の抽象化**
   - リスク: 過剰な設計により複雑性が増す可能性
   - 対策: シンプリシティを最優先し、必要な抽象化のみを導入

## 9. まとめ

本ドキュメントでは、jicanicleプロジェクトのアーキテクチャ再設計提案を行いました。現在の技術的課題を解決し、核となる機能要件を効果的に実現するための方向性を示しています。

提案するアーキテクチャは、ヘキサゴナルアーキテクチャと関数型アプローチを組み合わせ、テスト容易性と保守性を高めつつ、ユーザー価値を効果的に提供することを目指しています。

段階的な移行戦略により、リスクを最小化しながら新アーキテクチャへの移行を進めることが可能です。この再設計により、現在の技術的負債を解消し、より持続可能な開発を実現できると考えます。

## 関連ドキュメント

- [アーキテクチャ概要](../../architecture/overview.md)
- [ドメインモデル設計](../../design/domain-model.md)
- [核となる機能要件分析](./core-requirements-analysis.md)
- [核となる機能要件・仕様](./core-features-requirements.md)