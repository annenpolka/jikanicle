# jikanicle 完全リブート 実装計画

## 更新履歴

| 日付 | 更新者 | 内容 |
|------|--------|------|
| 2025-03-10 | 開発チーム | 初版作成：リブートの総括と実装計画の提案 |
| 2025-03-11 | 開発チーム | 更新：既存コード完全廃止と新規構築方針への転換 |

## 1. はじめに

jikanicleプロジェクトのリブート検討を通じて、現在の技術的課題（TUIのテスト困難性、Reactの複雑なコンテキスト依存、過度に複雑化したアーキテクチャ）を分析し、複数のアプローチを検討してきました。その結果、**既存コードを完全に廃止し**、一から再構築するという方針に決定しました。本ドキュメントでは、これまでの検討結果を総括し、新規構築のための実装計画を提案します。

## 2. 検討プロセスの概要

リブート検討においては、以下のステップで分析と提案を行いました：

1. **核となる機能要件の分析**
   - 現在の技術的課題の特定
   - 既存ドキュメントからの核機能の抽出
   - リブート検討の方針の設定

2. **核となる機能要件・仕様の整理**
   - 本質的な価値提案の明確化
   - 4つの主要機能モジュールの核機能の特定
   - モジュール間連携の本質的要素の抽出

3. **アーキテクチャ再設計の提案**
   - ヘキサゴナルアーキテクチャの検討
   - 段階的移行戦略の提案
   - テスト容易性の向上方法の検討

4. **軽量進化型アプローチの提案**
   - DDDアプローチ自体の再検討
   - 機能指向アーキテクチャの提案
   - 小さな反復的ステップでの漸進的改善手法の検討

## 3. 最終的な方針決定

### 3.1 既存コードの完全廃止と新規構築

検討の結果、既存コードを部分的に改修するのではなく、**完全に廃止し一から再構築する**方針を採用します。この決定に至った理由は以下の通りです：

1. **根本的な技術的課題の解決**
   - 現状の構造的問題を完全に解決するには抜本的な再設計が必要
   - パッチワーク的な改修では長期的な保守性向上が見込めない
   - クリーンな状態からの再出発により技術的負債を一掃

2. **シンプル性の優先**
   - 過度な抽象化や複雑な構造よりも理解しやすさを重視
   - 現在の課題の多くが複雑さに起因していることを考慮
   - 新規構築により不要な複雑性を排除

3. **実用性とコスト効率**
   - 理論的な「正しさ」よりも実際の開発効率と保守性を優先
   - プロジェクト規模に見合ったアプローチの採用
   - 長期的なメンテナンスコストの削減

4. **フィードバックループの強化**
   - 小さなマイルストーンでの検証を可能にする設計
   - ユーザーニーズへの迅速な対応
   - 継続的な改善の土台作り

### 3.2 推奨アプローチ：機能指向アーキテクチャ

完全リブートにあたり、以下の機能指向アーキテクチャの採用を推奨します：

1. **機能指向のモジュール構造**
   ```
   src/
   ├── features/          # 機能ごとのモジュール
   │   ├── tasks/         # タスク管理機能
   │   ├── timeblock/     # タイムブロック機能
   │   ├── tracking/      # タイムトラッキング機能
   │   └── prediction/    # AI予測機能
   ├── shared/            # 共有コンポーネントとユーティリティ
   ├── core/              # コアロジックと型定義
   └── index.ts           # エントリーポイント
   ```

2. **純粋関数と型駆動設計**
   - TypeScriptの型システムを最大限活用した安全性の確保
   - 純粋関数を中心としたロジック実装
   - 副作用の局所化と明示的な管理

3. **最小限の抽象化**
   - 必要に応じた抽象化の導入（早すぎる抽象化を避ける）
   - 具体的なユースケースからの設計導出
   - コロケーション原則による関連コードの集約

4. **段階的な実装と進化**
   - 小さなマイルストーンでの確実な前進
   - 継続的なリファクタリングサイクルの導入
   - 各段階での動作検証とフィードバック収集

## 4. 具体的な実装計画

### 4.1 ロードマップ

以下の4つのフェーズに分けて新規実装を進めます：

#### フェーズ1：基盤構築（1〜2週間）

**目標**: 新しいアーキテクチャの基盤を整備し、基本的なタスク管理機能を実装する

**具体的なタスク**:
1. プロジェクト構造の新規作成
   - 機能指向の構造の構築
   - 共通型定義の整備
   - 基本的なビルド設定とテスト環境の構築

2. タスクデータモデルの作成
   ```typescript
   type TaskId = string;

   type Task = {
     id: TaskId;
     name: string;
     description?: string;
     estimatedMinutes: number;
     category: 'work' | 'personal' | 'learning' | 'other';
     status: 'notStarted' | 'inProgress' | 'completed';
     createdAt: Date;
   };
   ```

3. ストレージメカニズムの実装
   ```typescript
   interface TaskStorage {
     save(task: Task): Promise<void>;
     findById(id: TaskId): Promise<Task | null>;
     findAll(): Promise<Task[]>;
     delete(id: TaskId): Promise<void>;
   }

   // ファイルベース実装
   function createFileTaskStorage(filePath: string): TaskStorage {
     // 実装...
   }
   ```

4. 基本的なCRUD操作の実装
   - タスク作成関数
   - タスク更新関数
   - タスク削除関数
   - タスクリスト取得関数

5. シンプルなUI実装
   - タスクリスト表示
   - タスク作成フォーム
   - タスク状態管理

**成果物**:
- 基本的なタスク管理機能が動作するアプリケーション
- 新しいアーキテクチャパターンの基盤実装

#### フェーズ2：タイムトラッキング機能（1〜2週間）

**目標**: タスク実行時間を計測し記録する機能を追加する

**具体的なタスク**:
1. タイマー機能の実装
   - 開始・停止・リセット機能
   - 経過時間の表示

2. セッション記録機能の追加
   ```typescript
   type TrackingSession = {
     taskId: TaskId;
     startTime: Date;
     endTime?: Date;
     durationMinutes?: number;
     breaks: {
       startTime: Date;
       endTime?: Date;
       durationMinutes?: number;
     }[];
   };
   ```

3. タスクと実績時間の連携
   - 実績時間の記録と表示
   - タスク完了時の統計処理

4. シンプルな統計情報の実装
   - カテゴリ別の時間使用統計
   - 予測時間と実績時間の比較

**成果物**:
- タイマー機能を備えたタスク管理アプリケーション
- 実績時間の記録と統計表示機能

#### フェーズ3：タイムブロッキング機能（2週間）

**目標**: タスクをスケジュール上のタイムブロックとして管理する機能を追加する

**具体的なタスク**:
1. タイムブロックデータモデルの実装
   ```typescript
   type TimeBlockId = string;

   type TimeBlock = {
     id: TimeBlockId;
     taskId: TaskId;
     startTime: Date;
     endTime: Date;
     isCompleted: boolean;
   };
   ```

2. シンプルなスケジュール表示の実装
   - 日単位のタイムライン表示
   - 現在のタイムブロックのハイライト

3. 基本的なスケジューリングロジックの実装
   - 予測時間に基づくタイムブロック生成
   - 時間枠内での最適配置

4. タイムブロックの調整機能
   - タイムブロックの移動・リサイズ
   - タイムブロックの分割・結合

**成果物**:
- タイムブロック管理機能を備えたアプリケーション
- スケジュール表示と調整機能

#### フェーズ4：AI予測機能（2〜3週間）

**目標**: タスクの所要時間を予測する基本的なAI機能を追加する

**具体的なタスク**:
1. シンプルな予測アルゴリズムの実装
   - 過去のデータに基づく基本的な予測
   - カテゴリ別の予測モデル

2. 予測モデルの学習メカニズムの実装
   - 実績データの収集と整形
   - モデルの更新処理

3. 予測結果のフィードバック収集
   - 予測精度の評価
   - ユーザーフィードバックの取り込み

4. 予測の信頼度表示
   - 予測の確信度の計算
   - ユーザーへの適切な提示方法

**成果物**:
- 基本的なAI予測機能を備えたアプリケーション
- フィードバックループによる自己改善システム

### 4.2 技術スタック選定（保留）

具体的な技術スタックの選定については、現時点では保留とします。実装フェーズを進めながら、各機能モジュールに最適な技術を選定していく柔軟なアプローチを採用します。ただし、以下の基本方針は維持します：

1. **言語**: TypeScript（型安全性により開発効率と品質向上が期待できる）
2. **モジュール性の確保**: 機能モジュール間の疎結合を実現できる設計
3. **テスト容易性**: 自動テストを前提とした実装アプローチ

### 4.3 実装アプローチ

各フェーズの実装においては、以下のアプローチを適用します：

1. **スモールステップの開発サイクル**
   - 1週間単位のイテレーション
   - 各イテレーションで明確な成果物を設定
   - デイリーコミットによる進捗の可視化

2. **テストファースト開発**
   - コア機能のテストを先行実装
   - ユースケースごとのテスト整備
   - 継続的なテスト実行

3. **リファクタリングの習慣化**
   - 週1回の定期リファクタリングセッション
   - コードスメルの早期発見と対応
   - 技術的負債の蓄積防止

4. **ユーザーフィードバックの活用**
   - 各フェーズ終了時の使用感レビュー
   - フィードバックに基づく優先順位調整
   - 実際の使用パターンの観察と学習

## 5. 新規構築戦略

既存コードを完全に廃止し新規構築する方針のため、移行戦略ではなく新規構築戦略に焦点を当てます：

### 5.1 完全新規構築アプローチ

1. **既存コードからの完全分離**
   - 既存コードベースは参照用途のみで残す
   - 新規プロジェクトとして一から実装を開始
   - コードの再利用は行わず、アイデアのみ参考にする

2. **データ互換性の考慮**
   - 既存データフォーマットの分析（必要な場合のみ）
   - 新しいデータモデルへの変換ツールの作成（オプション）
   - 完全に新しいデータ形式の採用も検討

3. **新旧システムの切り替え**
   - 新システムが十分な機能を備えた時点で完全切り替え
   - 移行期間は最小限に抑える
   - 旧バージョンはアーカイブとして保存

### 5.2 リスク管理

1. **技術的リスクへの対策**
   - 各フェーズの開始前にプロトタイプで検証
   - 複雑な機能は小さな単位に分割して実装
   - 不明確な部分は早期に実験的実装で検証

2. **スコープと期間の管理**
   - 明確なMVP定義によるスコープの絞り込み
   - タイムボックス開発による期間の制御
   - 機能の優先順位付けと段階的リリース計画

3. **品質保証**
   - 自動テストによる品質担保
   - 手動検証プロセスの確立
   - 早期ユーザーフィードバックの収集

## 6. まとめと次のステップ

jikanicleプロジェクトの完全リブートにおいては、既存コードを廃止し、機能指向アーキテクチャに基づいた新規構築を行います。シンプルさと実用性を重視し、小さな反復的ステップで確実に前進していきます。

### 6.1 次のアクション

1. **新規プロジェクト構造の構築**
   - 新しいリポジトリもしくはブランチの作成
   - 基本的なプロジェクト設定
   - ビルド設定とテスト環境の構築

2. **フェーズ1の着手**
   - タスク管理モジュールのデータモデル設計と実装
   - ストレージメカニズムの構築
   - 基本UI実装

3. **進捗管理の仕組み構築**
   - マイルストーンとタスクの詳細化
   - 週次レビューの設定
   - フィードバックループの構築

このアプローチにより、既存の技術的課題から完全に解放された、シンプルで保守性の高いアプリケーションを実現していきます。

## 関連ドキュメント

- [核となる機能要件分析](./core-requirements-analysis.md)
- [核となる機能要件・仕様](./core-features-requirements.md)
- [アーキテクチャ再設計提案](./architecture-redesign-proposal.md)
- [リブート分析概要](./reboot-analysis-summary.md)
- [軽量進化型アプローチの提案](./lightweight-evolution-approach.md)