# jicanicle 軽量進化型アプローチの提案

## 更新履歴

| 日付 | 更新者 | 内容 |
|------|--------|------|
| 2025-03-10 | 開発チーム | 初版作成：DDD以外の軽量アプローチと段階的改善プロセスの提案 |

## 1. はじめに

jicanicleプロジェクトのリブート検討において、DDD的アプローチ自体を再検討し、よりシンプルで軽量な構造による実装と段階的な改善プロセスを提案します。本ドキュメントでは、小さな反復的ステップで漸進的に改善を進め、各段階で価値を提供しながら柔軟に進化させる方法について検討します。

## 2. 現状のDDDアプローチの課題

現在のDDDベースのアプローチには以下の課題があります：

1. **構造の複雑さ**
   - 多層レイヤー構造による理解の難しさ
   - 多数の抽象コンセプト（集約、エンティティ、値オブジェクト、リポジトリなど）による認知負荷
   - コンテキスト境界の定義と維持が難しい

2. **実装コストの高さ**
   - 初期設計に多大な時間と労力が必要
   - ボイラープレートコードが多い
   - 変更時の影響範囲の把握が難しい

3. **学習曲線の急峻さ**
   - チーム全体での理解と統一的な実装が難しい
   - 新メンバーの参入障壁が高い

4. **小規模プロジェクトへの過剰適合**
   - 機能要件に対して過度に複雑なアーキテクチャとなっている
   - メンテナンスコストが便益を上回る可能性

## 3. 軽量進化型アプローチの提案

### 3.1 基本原則

軽量進化型アプローチでは、以下の原則に基づいてプロジェクトを進めます：

1. **シンプルさの追求**
   - 必要最小限の抽象化と明確な責務分担
   - 自然な理解が可能なコード構造
   - 不要な複雑さの排除

2. **段階的な進化**
   - 一度に全体を作り変えるのではなく、小さな改善を継続的に行う
   - 各段階でユーザー価値を確実に提供
   - フィードバックに基づく方向性の調整

3. **柔軟なアーキテクチャ**
   - 変更を前提とした設計
   - 過剰な事前設計よりも実際のニーズに基づく最適化
   - 凝り固まったパターンよりも機能に適したアプローチ

4. **実用性重視**
   - 理論的な「正しさ」より使いやすさとメンテナンス性
   - 開発効率とユーザー体験の向上
   - テスト容易性と安定性の確保

### 3.2 代替アプローチ：機能指向アーキテクチャ

DDDに代わるアプローチとして、「機能指向アーキテクチャ」を提案します：

```
src/
├── features/          # 機能ごとのモジュール
│   ├── tasks/         # タスク管理機能
│   │   ├── model.ts   # データモデルとロジック
│   │   ├── ui.tsx     # UI実装
│   │   ├── storage.ts # 永続化処理
│   │   ├── hooks.ts   # カスタムフック
│   │   └── index.ts   # 公開インターフェース
│   ├── timeblock/     # タイムブロック機能
│   ├── tracking/      # タイムトラッキング機能
│   └── prediction/    # AI予測機能
├── shared/            # 共有コンポーネントとユーティリティ
│   ├── ui/            # 共有UIコンポーネント
│   ├── utils/         # ユーティリティ関数
│   └── api/           # 外部API連携
├── core/              # コアロジックと型定義
│   ├── types.ts       # 共通型定義
│   ├── errors.ts      # エラーハンドリング
│   └── config.ts      # アプリケーション設定
└── index.ts           # エントリーポイント
```

この構造の特徴：

1. **機能による分割**
   - 技術的レイヤーではなく機能（ユーザーストーリー）で分割
   - 関連するコードが集約され、変更の局所化が容易
   - 機能単位でのリファクタリングや拡張が行いやすい

2. **コロケーション原則**
   - 関連するモデル、UI、ストレージを同じディレクトリに配置
   - コードナビゲーションが容易になり、関連コードを把握しやすい
   - 機能間の依存関係が明示的になる

3. **明示的なインターフェース**
   - 各機能は明確なインターフェースを通じて公開
   - 機能内部の実装詳細は隠蔽
   - 機能間の結合を制御しやすい

### 3.3 実装原則

実装においては以下の原則を採用します：

1. **型駆動設計**
   - ドメインモデルをTypeScriptの型として表現
   - インターフェースと実装の分離
   - 型による安全性の確保

   ```typescript
   // 例：シンプルなタスクモデル
   type TaskId = string;

   type Task = {
     id: TaskId;
     name: string;
     description?: string;
     estimatedMinutes: number;
     actualMinutes?: number;
     category: 'work' | 'personal' | 'learning' | 'other';
     status: 'notStarted' | 'inProgress' | 'completed';
     createdAt: Date;
     completedAt?: Date;
   };
   ```

2. **関数型アプローチの活用**
   - 純粋関数による予測可能な処理
   - データ変換パイプラインの活用
   - 副作用の局所化

   ```typescript
   // 例：純粋関数によるタスク操作
   function createTask(name: string, category: Task['category'], estimatedMinutes: number): Task {
     return {
       id: generateId(),
       name,
       category,
       estimatedMinutes,
       status: 'notStarted',
       createdAt: new Date(),
     };
   }

   function completeTask(task: Task, actualMinutes: number): Task {
     return {
       ...task,
       status: 'completed',
       actualMinutes,
       completedAt: new Date(),
     };
   }
   ```

3. **最小限の抽象化**
   - オーバーエンジニアリングを避ける
   - 必要に応じて抽象化を導入する（早すぎる抽象化を避ける）
   - 具体的なユースケースから設計を導出

4. **環境依存の分離**
   - 外部依存（ファイルシステム、API等）をモジュール境界に配置
   - 依存注入による結合度の低減
   - テスト容易性の確保

   ```typescript
   // 例：ストレージインターフェースと実装の分離
   interface TaskStorage {
     save(task: Task): Promise<void>;
     findById(id: TaskId): Promise<Task | null>;
     findAll(): Promise<Task[]>;
     delete(id: TaskId): Promise<void>;
   }

   // ファイルベース実装
   function createFileTaskStorage(filePath: string): TaskStorage {
     // 実装...
   }

   // インメモリ実装（テスト用）
   function createMemoryTaskStorage(): TaskStorage {
     const tasks = new Map<TaskId, Task>();
     return {
       save: async (task) => { tasks.set(task.id, task); },
       findById: async (id) => tasks.get(id) || null,
       findAll: async () => Array.from(tasks.values()),
       delete: async (id) => { tasks.delete(id); },
     };
   }
   ```

## 4. 段階的な実装と進化

### 4.1 マイルストーンベースの開発

大きなリブートではなく、小さなマイルストーンに分けて段階的に改善します：

1. **フェーズ1：基盤の整備**
   - コアデータモデルのシンプル化
   - ストレージメカニズムの刷新
   - 基本的なCRUD機能の実装

2. **フェーズ2：タイムトラッキング機能**
   - シンプルなタイマー機能
   - タスク実行時間の記録
   - 基本的な統計情報の表示

3. **フェーズ3：タイムブロッキング機能**
   - シンプルなスケジュール表示
   - タイムブロック生成ロジック
   - スケジュール調整機能

4. **フェーズ4：AI予測機能**
   - 基本的な予測アルゴリズム
   - フィードバックの収集
   - 予測精度の向上

各フェーズで必ず動作する製品を提供し、ユーザーフィードバックを得ながら次のフェーズの方向性を調整します。

### 4.2 リファクタリングサイクル

段階的な改善のために、以下のリファクタリングサイクルを導入します：

1. **観察**: 現在のコードの問題点や改善点を特定
2. **計画**: 小さな改善単位を計画
3. **テスト**: 変更前の動作を保証するテストを作成
4. **変更**: 小さな範囲で改善を実施
5. **検証**: テストによる動作確認と手動確認
6. **統合**: 変更をメインコードベースに統合
7. **繰り返し**: 次の改善点に移行

このサイクルを繰り返し、継続的に小さな改善を積み重ねていきます。

### 4.3 進化の具体例

#### 現状のタスク管理コードを段階的に改善する例：

**ステップ1：シンプルなモデルとストレージの導入**

```typescript
// features/tasks/model.ts
export type Task = {
  id: string;
  name: string;
  category: string;
  estimatedMinutes: number;
  status: 'notStarted' | 'inProgress' | 'completed';
};

// features/tasks/storage.ts
export interface TaskStorage {
  save(task: Task): Promise<void>;
  findAll(): Promise<Task[]>;
}

export function createFileTaskStorage(filePath: string): TaskStorage {
  // シンプルな実装...
}
```

**ステップ2：基本的なUI実装**

```typescript
// features/tasks/ui.tsx
export function TaskList({ tasks }: { tasks: Task[] }) {
  // シンプルなリスト表示
}

export function TaskForm({ onSubmit }: { onSubmit: (task: Omit<Task, 'id'>) => void }) {
  // シンプルなフォーム
}
```

**ステップ3：コア機能のフック化**

```typescript
// features/tasks/hooks.ts
export function useTasks() {
  const [tasks, setTasks] = useState<Task[]>([]);

  useEffect(() => {
    // タスク読み込みロジック
  }, []);

  const addTask = useCallback((taskData: Omit<Task, 'id'>) => {
    // タスク追加ロジック
  }, []);

  const completeTask = useCallback((id: string) => {
    // タスク完了ロジック
  }, []);

  return { tasks, addTask, completeTask };
}
```

**ステップ4：機能の洗練**

後続のステップで、必要に応じて機能を洗練させていきます：
- タスク編集機能の追加
- フィルタリングの実装
- 詳細表示の改善
- タイムトラッキング機能との連携

## 5. テスト戦略

軽量アプローチに合わせた効率的なテスト戦略を採用します：

### 5.1 テストの種類

1. **単体テスト**
   - 純粋関数とユーティリティの検証
   - モデル変換ロジックの検証
   - 境界条件と例外処理の検証

2. **統合テスト**
   - ストレージ機能の検証
   - 機能内の各モジュール連携の検証
   - 主要ユースケースの検証

3. **UI検証**
   - コンポーネントの基本動作確認
   - ユーザーインタラクションの検証
   - 状態変化の反映確認

### 5.2 テスト方針

1. **テスト優先度の設定**
   - コアロジックと重要ユースケースを優先
   - 頻繁に変更される部分より安定したAPIを優先
   - エッジケースよりハッピーパスを優先

2. **テスト設計の簡素化**
   - 複雑なモックやスタブの構築を最小化
   - テスト専用APIの過度な抽象化を避ける
   - シンプルで理解しやすいテストケース

3. **継続的なテスト実行**
   - 変更ごとに関連テストを実行
   - CIでの自動テスト実行
   - テスト結果に基づく迅速な修正

## 6. 移行戦略

現行コードベースから軽量アプローチへの移行戦略を示します：

### 6.1 段階的移行プロセス

1. **機能の特定と優先順位付け**
   - 核となる機能を特定し、優先順位を決定
   - 機能間の依存関係を分析
   - 移行順序を計画

2. **並行開発アプローチ**
   - 機能ごとに新実装を開発
   - 古い実装と新実装を一時的に共存させる
   - 機能単位で段階的に切り替え

3. **アダプターパターンの活用**
   - 新旧インターフェース間のアダプターを実装
   - 移行期間中のデータ互換性を確保
   - 移行完了後にアダプターを除去

### 6.2 移行のマイルストーン

1. **コアモデルの移行**
   - シンプルなタスクモデルの実装
   - 基本的なストレージ機能の実装
   - 現行データの新形式への変換

2. **UI機能の段階的移行**
   - コンポーネント単位でのリプレース
   - 状態管理の簡素化
   - ユーザー体験の一貫性確保

3. **高度機能の段階的再実装**
   - タイムブロッキング機能の再実装
   - AI予測機能の再構築
   - レポート機能の再実装

## 7. まとめ

本ドキュメントでは、DDDアプローチに代わる軽量進化型アプローチを提案しました。このアプローチは以下の特徴を持ちます：

1. **シンプルな構造**
   - 機能指向のモジュール分割
   - 最小限の抽象化と明確な責務
   - コード理解と保守の容易さ

2. **段階的な進化**
   - 小さなマイルストーンでの着実な進行
   - 継続的なリファクタリングサイクル
   - フィードバックに基づく方向性調整

3. **実用性重視**
   - 理論より実践を優先
   - ユーザー価値と開発効率のバランス
   - 長期的な保守性と拡張性

このアプローチにより、プロジェクトの技術的課題を根本から解決しつつ、ユーザーに継続的に価値を提供することが可能になります。小さな成功体験を積み重ねながら、持続可能な開発プロセスを確立することを目指します。

## 関連ドキュメント

- [核となる機能要件分析](./core-requirements-analysis.md)
- [核となる機能要件・仕様](./core-features-requirements.md)
- [アーキテクチャ再設計提案](./architecture-redesign-proposal.md)
- [リブート分析概要](./reboot-analysis-summary.md)