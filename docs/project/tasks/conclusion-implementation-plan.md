# jicanicle リブート 実装計画

## 更新履歴

| 日付 | 更新者 | 内容 |
|------|--------|------|
| 2025-03-10 | 開発チーム | 初版作成：リブートの総括と実装計画の提案 |

## 1. はじめに

jicanicleプロジェクトのリブート検討を通じて、現在の技術的課題（TUIのテスト困難性、Reactの複雑なコンテキスト依存、過度に複雑化したアーキテクチャ）を分析し、複数のアプローチを検討してきました。本ドキュメントでは、これまでの検討結果を総括し、最終的な実装計画を提案します。

## 2. 検討プロセスの概要

リブート検討においては、以下のステップで分析と提案を行いました：

1. **核となる機能要件の分析**
   - 現在の技術的課題の特定
   - 既存ドキュメントからの核機能の抽出
   - リブート検討の方針の設定

2. **核となる機能要件・仕様の整理**
   - 本質的な価値提案の明確化
   - 4つのバウンデッドコンテキストの核機能の特定
   - コンテキスト間連携の本質的要素の抽出

3. **アーキテクチャ再設計の提案**
   - ヘキサゴナルアーキテクチャの検討
   - 段階的移行戦略の提案
   - テスト容易性の向上方法の検討

4. **軽量進化型アプローチの提案**
   - DDDアプローチ自体の再検討
   - 機能指向アーキテクチャの提案
   - 小さな反復的ステップでの漸進的改善手法の検討

## 3. 最終的な方針決定

### 3.1 DDDアプローチからの転換

当初はDDDアプローチを前提としていましたが、検討の結果、次の理由からより軽量な機能指向アプローチへの転換を推奨します：

1. **シンプル性の優先**
   - 過度な抽象化や複雑な構造よりも理解しやすさを重視
   - 現在の課題の多くが複雑さに起因していることを考慮

2. **段階的改善の実現性**
   - 大規模なリブートよりも小さな成功体験の積み重ねが実践的
   - 各段階で確実に価値を提供しながら進化させる

3. **実用性とコスト効率**
   - 理論的な「正しさ」よりも実際の開発効率と保守性を優先
   - プロジェクト規模に見合ったアプローチの採用

4. **フィードバックループの強化**
   - 小さな変更サイクルによるフィードバックの活用
   - ユーザーニーズへの迅速な対応

### 3.2 推奨アプローチ：軽量機能指向アーキテクチャ

jicanicleプロジェクトのリブートに対して、以下のアプローチを推奨します：

1. **機能指向のモジュール構造**
   ```
   src/
   ├── features/          # 機能ごとのモジュール
   │   ├── tasks/         # タスク管理機能
   │   ├── timeblock/     # タイムブロック機能
   │   ├── tracking/      # タイムトラッキング機能
   │   └── prediction/    # AI予測機能
   ├── shared/            # 共有コンポーネントとユーティリティ
   ├── core/              # コアロジックと型定義
   └── index.ts           # エントリーポイント
   ```

2. **純粋関数と型駆動設計**
   - TypeScriptの型システムを最大限活用した安全性の確保
   - 純粋関数を中心としたロジック実装
   - 副作用の局所化と明示的な管理

3. **最小限の抽象化**
   - 必要に応じた抽象化の導入（早すぎる抽象化を避ける）
   - 具体的なユースケースからの設計導出
   - コロケーション原則による関連コードの集約

4. **段階的な実装と進化**
   - 小さなマイルストーンでの確実な前進
   - 継続的なリファクタリングサイクルの導入
   - 各段階での動作検証とフィードバック収集

## 4. 具体的な実装計画

### 4.1 ロードマップ

以下の4つのフェーズに分けて実装を進めます：

#### フェーズ1：基盤構築（1〜2週間）

**目標**: 新しいアーキテクチャの基盤を整備し、基本的なタスク管理機能を実装する

**具体的なタスク**:
1. プロジェクト構造の再編成
   - 機能指向の構造への移行
   - 共通型定義の整備
   - 基本的なビルド設定とテスト環境の構築

2. タスクデータモデルの作成
   ```typescript
   type TaskId = string;

   type Task = {
     id: TaskId;
     name: string;
     description?: string;
     estimatedMinutes: number;
     category: 'work' | 'personal' | 'learning' | 'other';
     status: 'notStarted' | 'inProgress' | 'completed';
     createdAt: Date;
   };
   ```

3. ストレージメカニズムの実装
   ```typescript
   interface TaskStorage {
     save(task: Task): Promise<void>;
     findById(id: TaskId): Promise<Task | null>;
     findAll(): Promise<Task[]>;
     delete(id: TaskId): Promise<void>;
   }

   // ファイルベース実装
   function createFileTaskStorage(filePath: string): TaskStorage {
     // 実装...
   }
   ```

4. 基本的なCRUD操作の実装
   - タスク作成関数
   - タスク更新関数
   - タスク削除関数
   - タスクリスト取得関数

5. シンプルなUI実装
   - タスクリスト表示
   - タスク作成フォーム
   - タスク状態管理

**成果物**:
- 基本的なタスク管理機能が動作するアプリケーション
- 新しいアーキテクチャパターンのサンプル実装

#### フェーズ2：タイムトラッキング機能（1〜2週間）

**目標**: タスク実行時間を計測し記録する機能を追加する

**具体的なタスク**:
1. タイマー機能の実装
   - 開始・停止・リセット機能
   - 経過時間の表示

2. セッション記録機能の追加
   ```typescript
   type TrackingSession = {
     taskId: TaskId;
     startTime: Date;
     endTime?: Date;
     durationMinutes?: number;
     breaks: {
       startTime: Date;
       endTime?: Date;
       durationMinutes?: number;
     }[];
   };
   ```

3. タスクと実績時間の連携
   - 実績時間の記録と表示
   - タスク完了時の統計処理

4. シンプルな統計情報の実装
   - カテゴリ別の時間使用統計
   - 予測時間と実績時間の比較

**成果物**:
- タイマー機能を備えたタスク管理アプリケーション
- 実績時間の記録と統計表示機能

#### フェーズ3：タイムブロッキング機能（2週間）

**目標**: タスクをスケジュール上のタイムブロックとして管理する機能を追加する

**具体的なタスク**:
1. タイムブロックデータモデルの実装
   ```typescript
   type TimeBlockId = string;

   type TimeBlock = {
     id: TimeBlockId;
     taskId: TaskId;
     startTime: Date;
     endTime: Date;
     isCompleted: boolean;
   };
   ```

2. シンプルなスケジュール表示の実装
   - 日単位のタイムライン表示
   - 現在のタイムブロックのハイライト

3. 基本的なスケジューリングロジックの実装
   - 予測時間に基づくタイムブロック生成
   - 時間枠内での最適配置

4. タイムブロックの調整機能
   - タイムブロックの移動・リサイズ
   - タイムブロックの分割・結合

**成果物**:
- タイムブロック管理機能を備えたアプリケーション
- スケジュール表示と調整機能

#### フェーズ4：AI予測機能（2〜3週間）

**目標**: タスクの所要時間を予測する基本的なAI機能を追加する

**具体的なタスク**:
1. シンプルな予測アルゴリズムの実装
   - 過去のデータに基づく基本的な予測
   - カテゴリ別の予測モデル

2. 予測モデルの学習メカニズムの実装
   - 実績データの収集と整形
   - モデルの更新処理

3. 予測結果のフィードバック収集
   - 予測精度の評価
   - ユーザーフィードバックの取り込み

4. 予測の信頼度表示
   - 予測の確信度の計算
   - ユーザーへの適切な提示方法

**成果物**:
- 基本的なAI予測機能を備えたアプリケーション
- フィードバックループによる自己改善システム

### 4.2 技術スタック選定

本プロジェクトでは以下の技術スタックを推奨します：

1. **言語とフレームワーク**
   - TypeScript: 型安全性と開発効率のバランスが優れている
   - Node.js: サーバーサイドの処理とCLIアプリケーションに適している

2. **UIレイヤー**
   - blessed/neo-blessed: よりテスト性の高いTUI実装のために採用
   - または clack/prompts: モダンでシンプルなTUIコンポーネント

3. **状態管理**
   - Zustand: シンプルで柔軟性が高く、過度な抽象化を避けられる
   - または Jotai: アトミックな状態管理で複雑性を低減

4. **データバリデーション**
   - Zod: 型安全で宣言的なスキーマ定義

5. **エラーハンドリング**
   - neverthrow: Result型による明示的なエラーハンドリング

6. **テストフレームワーク**
   - Vitest: 高速で設定が容易、TypeScriptとの統合が優れている

7. **データ永続化**
   - ローカルファイルストレージ: シンプルさと可搬性を重視
   - JSON形式でのデータ保存: 読みやすさと互換性の確保

### 4.3 実装アプローチ

各フェーズの実装においては、以下のアプローチを適用します：

1. **スモールステップの開発サイクル**
   - 1週間単位のイテレーション
   - 各イテレーションで明確な成果物を設定
   - デイリーコミットによる進捗の可視化

2. **テストファースト開発**
   - コア機能のテストを先行実装
   - ユースケースごとのテスト整備
   - 継続的なテスト実行

3. **リファクタリングの習慣化**
   - 週1回の定期リファクタリングセッション
   - コードスメルの早期発見と対応
   - 技術的負債の蓄積防止

4. **ユーザーフィードバックの活用**
   - 各フェーズ終了時の使用感レビュー
   - フィードバックに基づく優先順位調整
   - 実際の使用パターンの観察と学習

## 5. 移行戦略

現行コードベースから新しいアプローチへの移行は、以下の方針で進めます：

### 5.1 段階的移行

1. **ストラングラーフィグパターンの適用**
   - 機能ごとに新実装を開発
   - 古い実装と新実装を一時的に共存させる
   - 機能単位で段階的に切り替え

2. **データ互換性の確保**
   - 移行期間中のデータ変換メカニズムを実装
   - バックアップと復元機能の整備
   - 移行検証用のテストケース作成

3. **並行運用期間の設定**
   - 各フェーズの新機能を選択的に有効化するフラグ機能
   - ユーザーによるオプトイン形式での新機能体験
   - フィードバックに基づく調整

### 5.2 リスク管理

1. **技術的リスクへの対策**
   - 各フェーズの開始前にプロトタイプで検証
   - 複雑な機能は小さな単位に分割して実装
   - フォールバックメカニズムの整備

2. **移行時のユーザー体験保護**
   - ユーザーデータの保全を最優先
   - UI変更を段階的に導入し習熟を促進
   - ヘルプドキュメントとチュートリアルの整備

3. **品質保証**
   - 自動テストによるリグレッション防止
   - 手動検証プロセスの確立
   - 早期ユーザーフィードバックの収集

## 6. まとめと次のステップ

jicanicleプロジェクトのリブートにおいては、DDDの複雑さを避け、軽量機能指向アーキテクチャを採用することで、より持続可能な開発と進化が可能になると判断します。小さな反復的ステップで漸進的に改善を進め、各段階で価値を提供しながら柔軟に進化させることを目指します。

### 6.1 次のアクション

1. **開発環境のセットアップ**
   - 新しいプロジェクト構造の整備
   - ビルド設定とテスト環境の構築
   - CIパイプラインの再設定

2. **フェーズ1の着手**
   - データモデルの設計と実装
   - ストレージメカニズムの構築
   - 基本UI実装

3. **進捗管理の仕組み構築**
   - マイルストーンとタスクの詳細化
   - 週次レビューの設定
   - フィードバックループの構築

このアプローチにより、迅速に価値を提供しながらも長期的に持続可能なアーキテクチャへと進化させることができます。技術的課題を解決しつつ、ユーザー体験の継続的な向上を実現していきます。

## 関連ドキュメント

- [核となる機能要件分析](./core-requirements-analysis.md)
- [核となる機能要件・仕様](./core-features-requirements.md)
- [アーキテクチャ再設計提案](./architecture-redesign-proposal.md)
- [リブート分析概要](./reboot-analysis-summary.md)
- [軽量進化型アプローチの提案](./lightweight-evolution-approach.md)