# インメモリタスクリポジトリ実装詳細

## 更新履歴
- 2025/3/9: 初版作成

## 実装の概要

TaskRepositoryインターフェースに基づいたインメモリ実装を提供します。このリポジトリは主に以下の目的で使用されます：

1. テスト環境での使用
2. 開発初期段階でのプロトタイピング
3. 永続化の必要がない一時的なタスク管理

実装は関数スタイルで行い、内部状態を管理するための不変なデータ構造を使用します。すべてのメソッドはResult型を返し、エラー処理を型安全に行います。

## 型定義とインターフェース

インメモリリポジトリは以下のインターフェースを実装します：

```typescript
export interface TaskRepository {
  findById(id: TaskId): Promise<Result<Task, TaskRepositoryError>>;
  findAll(filter?: TaskFilter): Promise<Result<Task[], TaskRepositoryError>>;
  save(task: Task): Promise<Result<Task, TaskRepositoryError>>;
  delete(id: TaskId): Promise<Result<void, TaskRepositoryError>>;
  count(filter?: TaskFilter): Promise<Result<number, TaskRepositoryError>>;
}
```

## 主要なロジックとアルゴリズム

### データ構造

インメモリ実装では、TaskエンティティをMapデータ構造に保存します。キーはTaskIdで、値はTaskオブジェクトです。

### オペレーション

1. **findById**: IDによるタスク検索。O(1)の時間複雑度。
2. **findAll**: フィルタリング条件に一致するすべてのタスクの取得。条件がない場合はすべてのタスクを返す。
3. **save**: 新規タスクの追加または既存タスクの更新。追加時にIDの重複チェックを行う。
4. **delete**: IDによるタスク削除。存在しない場合はエラー。
5. **count**: フィルタリング条件に一致するタスク数のカウント。

### フィルタリングロジック

`findAll`と`count`メソッドのフィルタリングは以下のルールに基づいて実装：

- **status**: タスクのステータスによるフィルタリング
- **category**: カテゴリによるフィルタリング
- **tags**: 指定されたタグをすべて含むタスクのフィルタリング
- **createdAfter/createdBefore**: 作成日時の範囲によるフィルタリング
- **textSearch**: タスク名と説明文に対するテキスト検索

### エラーハンドリング

Result型を使用して以下のエラーケースを処理：

- **NOT_FOUND**: 指定されたIDのタスクが存在しない
- **ALREADY_EXISTS**: 同じIDのタスクが既に存在する（保存時）
- **VALIDATION_ERROR**: タスクデータがバリデーションに失敗
- **CONCURRENCY_ERROR**: 楽観的ロックによる競合検出（将来的な拡張用）

## テスト戦略

以下のテストケースを実装：

1. **単体テスト**
   - 各メソッドの正常系ケース
   - 各メソッドのエラーケース
   - フィルタリング条件の組み合わせテスト

2. **特殊ケース**
   - 空のリポジトリ
   - 大量データの処理
   - 同時操作のシミュレーション

## 性能考慮事項

インメモリ実装のため基本的には高速ですが、以下の点に注意：

- フィルタリングは線形時間（O(n)）
- テキスト検索は単純な部分文字列マッチングで実装（本番環境では高度な検索機能が必要になる可能性あり）
- 大量のタスクを処理する場合、メモリ使用量に注意

## 今後の拡張性

将来的な拡張として以下を検討：

- ソート機能の追加
- ページネーション対応
- より高度な検索機能（全文検索など）
- パフォーマンス最適化（インデックス機能など）