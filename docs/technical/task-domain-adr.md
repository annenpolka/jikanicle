# タスク管理ドメイン 設計決定記録 (ADR)

## ADR 1: ドメインモデル設計アプローチ

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスク管理機能を実装するにあたり、ドメインモデルの設計アプローチを決定する必要がありました。特に、データの整合性、型安全性、拡張性を考慮する必要がありました。

### 決定

ドメイン駆動設計（DDD）の原則に基づいたアプローチを採用し、以下の要素を含むドメインモデルを構築することにしました：

1. **明確に定義された境界**: タスク管理を独立したドメインとして扱う
2. **値オブジェクトとエンティティの区別**: TaskId を値オブジェクトとして、Task をエンティティとして定義
3. **ファクトリパターン**: タスク作成のためのファクトリ関数の実装
4. **不変性の重視**: データの変更ではなく新しいオブジェクトの生成を基本とする

### 根拠

- DDD 原則は複雑なドメインロジックの管理に適している
- 明確な境界と責任の分離により、コードの保守性が向上する
- 型安全性と不変性により、予測可能な動作とバグの減少が期待できる

### 影響

- 新しい機能開発時には同様のアプローチが期待される
- チームメンバーは DDD の原則と実践について理解する必要がある
- 短期的には開発の初期コストが増加するが、長期的にはメンテナンスコストが削減される

---

## ADR 2: タスク ID の実装方法

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスクを一意に識別するための ID 実装方法を決定する必要がありました。文字列や数値を直接使用する単純なアプローチと、型安全性を高めるアプローチを検討しました。

### 決定

TypeScript のブランド型（Branded Types）を使用して、TaskId 型を実装することにしました。

```typescript
export type TaskId = string & { readonly _brand: unique symbol };

export const createTaskId = (id: string): TaskId => {
  return id as TaskId;
};
```

### 根拠

- ブランド型により、通常の文字列と TaskId を型レベルで区別できる
- コンパイル時に型チェックを行うことで、誤った型の使用を防止できる
- 実行時のオーバーヘッドなしに型安全性を向上させることができる

### 影響

- 他の ID 型（例：UserId など）も同様のパターンで実装する必要がある
- 型キャストが必要な場面があるが、ヘルパー関数によって安全に行うことができる

---

## ADR 3: バリデーションライブラリの選択

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスクデータのバリデーションを行うために、適切なバリデーションライブラリを選択する必要がありました。候補として、以下のライブラリを検討しました：

1. Zod
2. Joi
3. Yup
4. class-validator
5. 自作バリデーション

### 決定

Zod ライブラリを採用することにしました。

### 根拠

- **型推論の強力さ**: Zod は TypeScript との統合が優れており、スキーマから型を推論できる
- **宣言的な構文**: スキーマ定義が読みやすく、メンテナンスしやすい
- **エラーメッセージのカスタマイズ**: エラーメッセージを日本語化しやすい
- **パフォーマンス**: バンドルサイズとランタイムパフォーマンスのバランスが良い
- **アクティブな開発**: 継続的なメンテナンスとアップデートが行われている

### 影響

- アプリケーション全体で一貫して Zod を使用することが推奨される
- バリデーションスキーマとドメインモデルを同期させる必要がある
- 将来的な API レスポンスのバリデーションにも活用できる

---

## ADR 4: 列挙型の実装方法

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスクのカテゴリ、ステータス、優先度などの列挙型の実装方法を決定する必要がありました。TypeScript enums、文字列リテラルユニオン型、オブジェクト定数など、複数の選択肢がありました。

### 決定

文字列リテラルユニオン型を採用することにしました。

```typescript
export type Category =
  | 'WORK'
  | 'PERSONAL_DEV'
  | 'HOUSEHOLD'
  | 'LEARNING'
  | 'OTHER';

export type TaskStatus =
  | 'NOT_STARTED'
  | 'IN_PROGRESS'
  | 'COMPLETED'
  | 'CANCELLED';

export type Priority = 'LOW' | 'MEDIUM' | 'HIGH';
```

### 根拠

- **型安全性**: コンパイル時に有効な値をチェックできる
- **シリアライズの容易さ**: JSON 変換時に特別な処理が不要
- **ランタイムコード削減**: TypeScript enums と異なり、追加のランタイムコードが生成されない
- **明示性**: 許容される値が型定義で明確に示されている

### 影響

- UI コンポーネントでの選択肢表示に追加のマッピングが必要になる場合がある
- 列挙型の変更には型定義とバリデーションスキーマの両方の更新が必要になる

---

## ADR 5: テスト駆動開発（TDD）アプローチの採用

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスク管理ドメインの開発手法として、適切なテスト戦略を決定する必要がありました。実装先行、テスト後付けの従来型アプローチと TDD アプローチが主な選択肢でした。

### 決定

テスト駆動開発（TDD）アプローチを採用することにしました。

1. **赤**: まず失敗するテストを書く
2. **緑**: 最小限のコードでテストをパスさせる
3. **リファクタリング**: コードをクリーンアップしながらテストをパスし続ける

### 根拠

- **明確な要件の把握**: テストが仕様の役割を果たし、実装の目標が明確になる
- **適切な設計の促進**: テスト可能なコードを書くことで、自然と良い設計が導かれる
- **リグレッションの防止**: 変更によって既存機能が壊れないことを保証できる
- **ドキュメントとしての役割**: テストが機能の使用例としても機能する

### 影響

- 短期的には開発速度が低下する可能性がある
- チームメンバーが TDD の原則と実践に慣れる必要がある
- CI パイプラインにテストの実行を組み込む必要がある

---

## ADR 6: ファクトリパターンの採用

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスクオブジェクトの作成方法として、直接のオブジェクト生成、クラスコンストラクタ、ファクトリパターンなどの選択肢がありました。

### 決定

ファクトリ関数パターンを採用し、`createTask`関数を実装することにしました。

```typescript
export function createTask(params: CreateTaskParams): Task {
  // バリデーションとデフォルト値の適用
  const validParams = validateCreateTaskParams(params);

  // オブジェクト生成
  const task: Task = {
    // プロパティ設定
  };

  return task;
}
```

### 根拠

- **カプセル化**: 複雑な生成ロジックを隠蔽できる
- **バリデーション集約**: オブジェクト生成時のバリデーションを一か所で管理できる
- **デフォルト値**: 一貫したデフォルト値の適用が可能
- **関心の分離**: 生成ロジックとドメインロジックを分離できる

### 影響

- 他のドメインオブジェクトも同様のパターンで実装する必要がある
- タスク更新のためのファクトリ関数も同様のアプローチで実装する必要がある

---

## ADR 7: 日時の処理方法

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスクの createdAt、updatedAt、completedAt 日時フィールドの実装方法を決定する必要がありました。Date 型の直接使用、ISO 文字列、タイムスタンプ、外部ライブラリ（Moment.js、date-fns、Luxon）など、複数の選択肢がありました。

### 決定

JavaScript 組み込みの Date 型を使用することにしました。

```typescript
export interface Task {
  // ...その他のプロパティ
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}
```

### 根拠

- **シンプルさ**: 追加の依存関係なしで基本的な日時処理が可能
- **互換性**: JSON シリアライズ/デシリアライズが比較的容易
- **標準化**: JavaScript の標準ライブラリの一部として長期的なサポートが期待できる

### 影響

- 高度な日時操作が必要になった場合は、専門のライブラリを追加導入する可能性がある
- JSON との相互変換時には Date オブジェクトの特別な処理が必要になる

---

## ADR 8: 不変性の実装方針

**ステータス**: 承認済み

**日付**: 2024-03-11

### 背景

タスクオブジェクトの変更（更新）をどのように扱うかを決定する必要がありました。ミュータブルな更新とイミュータブルな更新の両方のアプローチが検討されました。

### 決定

イミュータブルなアプローチを採用し、オブジェクトの変更時には新しいオブジェクトを生成することにしました。

```typescript
// ミュータブルな更新（採用しないアプローチ）
function updateTaskStatus(task: Task, newStatus: TaskStatus): void {
  task.status = newStatus;
  task.updatedAt = new Date();
}

// イミュータブルな更新（採用するアプローチ）
function updateTaskStatus(task: Task, newStatus: TaskStatus): Task {
  return {
    ...task,
    status: newStatus,
    updatedAt: new Date(),
  };
}
```

### 根拠

- **予測可能性**: 副作用が少なく、データフローが追跡しやすい
- **並行処理の安全性**: 並行操作によるデータ破損のリスクが低減される
- **ステート管理の容易さ**: 状態変化の追跡と時間を遡った分析が容易になる
- **テストの容易さ**: 入力と出力の関係が明確で、テストが書きやすい

### 影響

- パフォーマンス上のオーバーヘッドが発生する可能性がある（オブジェクトの複製）
- 開発者はイミュータブルなデータ操作パターンに慣れる必要がある

## タイトル: Zod の Infer を使った型定義とスキーマの統合

### ステータス

承認済み

### 日付

2023-05-30

### 背景

タスク管理ドメインの実装において、TypeScript の型定義とランタイムバリデーションの整合性を維持する必要があった。従来のアプローチでは以下の問題が生じていた：

1. 型定義とバリデーションスキーマが二重管理されていた
2. スキーマと型の間に不一致が生じるリスクがあった
3. スキーマと型の更新が同期されないことがあった
4. コードの冗長性が高く、メンテナンスコストが増加していた

これらの問題を解決し、より堅牢なドメインモデルを実現するための手法を検討する必要があった。

### 決定

Zod スキーマから`z.infer<typeof schema>`を使用して型を生成し、型定義ファイルではそれらを再エクスポートする方式を採用する。この方式により：

1. スキーマ定義から型を自動生成し、単一の情報源とする
2. 型定義ファイルはスキーマから生成された型を再エクスポートする
3. 循環参照を避けるため、スキーマファイルは型定義ファイルをインポートしない

### 根拠

以下の理由からこのアプローチを選択した：

1. **型安全性**: スキーマと型が完全に同期するため、不一致によるバグが発生しない
2. **DRY 原則**: 定義を一度だけ行い、重複を防止できる
3. **保守性**: スキーマの変更が自動的に型に反映される
4. **開発効率**: 型とバリデーションロジックの二重メンテナンスが不要になる
5. **DDD の原則**: ドメインの制約をスキーマとして明示的に定義でき、それが型にも反映される

他の選択肢として以下を検討した：

- 手動で型とスキーマを同期させる → 人的ミスのリスクが高い
- コード生成ツールを使用する → ビルドプロセスが複雑になる
- 型定義を完全に削除し、すべてをスキーマから推論する → 既存コードとの互換性の問題

### 影響

#### 肯定的影響

1. 型とバリデーションの整合性が保証される
2. コードの冗長性が減少する
3. ドメインモデルの変更がより安全になる
4. リファクタリングのリスクが低減する

#### 懸念点

1. スキーマからの型推論が複雑な場合、型が読みにくくなる可能性がある
2. 高度な型機能（条件付き型など）の使用が制限される可能性がある
3. 開発者がこのパターンに不慣れな場合、学習コストがかかる

#### 対応策

1. 詳細な実装ドキュメントを作成（[zod-schema-implementation.md](./zod-schema-implementation.md)）
2. 必要に応じて型の使い分け方針を定義
3. 再エクスポートを通じて既存コードとの互換性を維持

### 関連リンク

- [zod-schema-implementation.md](./zod-schema-implementation.md) - 実装詳細ドキュメント
- [ドメインモデル定義](../design/domain-model.md)
