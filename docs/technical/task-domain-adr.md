# タスク管理ドメイン 設計決定記録 (ADR)

## ADR 1: ドメインモデル設計アプローチ

**ステータス**: 承認済み

**日付**: 2025-03-09

### 背景

タスク管理機能を実装するにあたり、ドメインモデルの設計アプローチを決定する必要がありました。特に、データの整合性、型安全性、拡張性を考慮する必要がありました。

### 決定

ドメイン駆動設計（DDD）の原則に基づいたアプローチを採用し、以下の要素を含むドメインモデルを構築することにしました：

1. **明確に定義された境界**: タスク管理を独立したドメインとして扱う
2. **値オブジェクトとエンティティの区別**: TaskId を値オブジェクトとして、Task をエンティティとして定義
3. **ファクトリパターン**: タスク作成のためのファクトリ関数の実装
4. **不変性の重視**: データの変更ではなく新しいオブジェクトの生成を基本とする

### 根拠

- DDD 原則は複雑なドメインロジックの管理に適している
- 明確な境界と責任の分離により、コードの保守性が向上する
- 型安全性と不変性により、予測可能な動作とバグの減少が期待できる

### 影響

- 新しい機能開発時には同様のアプローチが期待される
- チームメンバーは DDD の原則と実践について理解する必要がある
- 短期的には開発の初期コストが増加するが、長期的にはメンテナンスコストが削減される

---

## ADR 2: タスク識別子の設計

**ステータス**: 承認済み

**日付**: 2025-03-09

### 背景

タスクを一意に識別するための ID 実装方法を決定する必要がありました。文字列や数値を直接使用する単純なアプローチと、型安全性を高めるアプローチを検討しました。

### 決定

TypeScript のブランド型（Branded Types）を使用して、TaskId 型を実装することにしました。

```typescript
export type TaskId = string & { readonly _brand: unique symbol };

export const createTaskId = (id: string): TaskId => {
  return id as TaskId;
};
```

### 根拠

- ブランド型により、通常の文字列と TaskId を型レベルで区別できる
- コンパイル時に型チェックを行うことで、誤った型の使用を防止できる
- 実行時のオーバーヘッドなしに型安全性を向上させることができる

### 影響

- 他の ID 型（例：UserId など）も同様のパターンで実装する必要がある
- 型キャストが必要な場面があるが、ヘルパー関数によって安全に行うことができる

---

## ADR 3: タスク状態管理方式

**ステータス**: 承認済み

**日付**: 2025-03-09

### 背景

タスクの状態管理方式を決定する必要がありました。タスクのステータスを管理するための適切な方法を検討しました。

### 決定

タスクの状態を列挙型として管理することにしました。

```typescript
export type TaskStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';
```

### 根拠

- **型安全性**: コンパイル時に有効な値をチェックできる
- **シリアライズの容易さ**: JSON 変換時に特別な処理が不要
- **ランタイムコード削減**: TypeScript enums と異なり、追加のランタイムコードが生成されない
- **明示性**: 許容される値が型定義で明確に示されている

### 影響

- タスクの状態管理がより明確になる
- タスクの状態遷移のバリデーションが容易になる
- タスクの状態に基づくロジックの実装が容易になる

---

## ADR 4: タスク予測時間の精度と表現

**ステータス**: 承認済み

**日付**: 2025-03-09

### 背景

タスクの予測時間の精度と表現方法を決定する必要がありました。タスクの予測時間を管理するための適切な方法を検討しました。

### 決定

タスクの予測時間を日数で管理することにしました。

```typescript
export interface Task {
  // ...その他のプロパティ
  estimatedDuration: number;
}
```

### 根拠

- **シンプルさ**: 日数での管理は直感的で理解しやすい
- **互換性**: 従来の日数ベースの予測方法との互換性が保たれる
- **標準化**: 業界標準として一般的に使用されている

### 影響

- タスクの予測時間がより正確に管理される
- タスクのスケジューリングとリソース管理が容易になる
- タスクの完了予測の信頼性が向上する

---

## ADR 5: タスクカテゴリ体系

**ステータス**: 承認済み

**日付**: 2025-03-09

### 背景

タスクのカテゴリ体系を決定する必要がありました。タスクを分類するための適切な方法を検討しました。

### 決定

タスクのカテゴリを列挙型として管理することにしました。

```typescript
export type Category =
  | 'WORK'
  | 'PERSONAL_DEV'
  | 'HOUSEHOLD'
  | 'LEARNING'
  | 'OTHER';
```

### 根拠

- **型安全性**: コンパイル時に有効な値をチェックできる
- **シリアライズの容易さ**: JSON 変換時に特別な処理が不要
- **ランタイムコード削減**: TypeScript enums と異なり、追加のランタイムコードが生成されない
- **明示性**: 許容される値が型定義で明確に示されている

### 影響

- タスクのカテゴリ管理がより明確になる
- タスクのカテゴリに基づくフィルタリングと検索が容易になる
- タスクのカテゴリに基づくロジックの実装が容易になる

---

## ADR 6: 優先度システム

**ステータス**: 承認済み

**日付**: 2025-03-09

### 背景

タスクの優先度を管理するための適切な方法を決定する必要がありました。タスクの優先度を管理するための適切な方法を検討しました。

### 決定

タスクの優先度を列挙型として管理することにしました。

```typescript
export type Priority = 'LOW' | 'MEDIUM' | 'HIGH';
```

### 根拠

- **型安全性**: コンパイル時に有効な値をチェックできる
- **シリアライズの容易さ**: JSON 変換時に特別な処理が不要
- **ランタイムコード削減**: TypeScript enums と異なり、追加のランタイムコードが生成されない
- **明示性**: 許容される値が型定義で明確に示されている

### 影響

- タスクの優先度管理がより明確になる
- タスクの優先度に基づくフィルタリングと検索が容易になる
- タスクの優先度に基づくロジックの実装が容易になる

---

## ADR 7: タグシステムの柔軟性と制約

**ステータス**: 承認済み

**日付**: 2025-03-09

### 背景

タスクのタグシステムの柔軟性と制約を決定する必要がありました。タスクにタグを付けるための適切な方法を検討しました。

### 決定

タスクにタグを付けるための適切な方法を決定することにしました。

```typescript
export interface Task {
  // ...その他のプロパティ
  tags: string[];
}
```

### 根拠

- **柔軟性**: タスクに複数のタグを付けることができる
- **制約**: タグの数や長さに制限を設けることができる
- **ドメインの制約**: タグはドメインの制約に基づいて付けることができる

### 影響

- タスクの検索とフィルタリングが容易になる
- タスクのカテゴリに基づくフィルタリングと検索が容易になる
- タスクの優先度に基づくフィルタリングと検索が容易になる

## タイトル: Zod の Infer を使った型定義とスキーマの統合

### ステータス

承認済み

### 日付

2025-03-09

### 背景

タスク管理ドメインの実装において、TypeScript の型定義とランタイムバリデーションの整合性を維持する必要があった。従来のアプローチでは以下の問題が生じていた：

1. 型定義とバリデーションスキーマが二重管理されていた
2. スキーマと型の間に不一致が生じるリスクがあった
3. スキーマと型の更新が同期されないことがあった
4. コードの冗長性が高く、メンテナンスコストが増加していた

これらの問題を解決し、より堅牢なドメインモデルを実現するための手法を検討する必要があった。

### 決定

Zod スキーマから`z.infer<typeof schema>`を使用して型を生成し、型定義ファイルではそれらを再エクスポートする方式を採用する。この方式により：

1. スキーマ定義から型を自動生成し、単一の情報源とする
2. 型定義ファイルはスキーマから生成された型を再エクスポートする
3. 循環参照を避けるため、スキーマファイルは型定義ファイルをインポートしない

### 根拠

以下の理由からこのアプローチを選択した：

1. **型安全性**: スキーマと型が完全に同期するため、不一致によるバグが発生しない
2. **DRY 原則**: 定義を一度だけ行い、重複を防止できる
3. **保守性**: スキーマの変更が自動的に型に反映される
4. **開発効率**: 型とバリデーションロジックの二重メンテナンスが不要になる
5. **DDD の原則**: ドメインの制約をスキーマとして明示的に定義でき、それが型にも反映される

他の選択肢として以下を検討した：

- 手動で型とスキーマを同期させる → 人的ミスのリスクが高い
- コード生成ツールを使用する → ビルドプロセスが複雑になる
- 型定義を完全に削除し、すべてをスキーマから推論する → 既存コードとの互換性の問題

### 影響

#### 肯定的影響

1. 型とバリデーションの整合性が保証される
2. コードの冗長性が減少する
3. ドメインモデルの変更がより安全になる
4. リファクタリングのリスクが低減する

#### 懸念点

1. スキーマからの型推論が複雑な場合、型が読みにくくなる可能性がある
2. 高度な型機能（条件付き型など）の使用が制限される可能性がある
3. 開発者がこのパターンに不慣れな場合、学習コストがかかる

#### 対応策

1. 詳細な実装ドキュメントを作成（[zod-schema-implementation.md](./zod-schema-implementation.md)）
2. 必要に応じて型の使い分け方針を定義
3. 再エクスポートを通じて既存コードとの互換性を維持

### 関連リンク

- [zod-schema-implementation.md](./zod-schema-implementation.md) - 実装詳細ドキュメント
- [ドメインモデル定義](../design/domain-model.md)
